
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>百度历年笔试面试题(29) | yangpengACE`s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="peng yang">
    
    <meta name="description" content="1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。
1
2
3
4
5
6
7
8
9
10
char *revert(char *str){
    int n = strlen(str);
    int i = 0;
    for(int i = 0; i &amp;">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="yangpengACE`s Blog" title="yangpengACE`s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="yangpengACE`s Blog">yangpengACE`s Blog</a></h1>
				<h2 class="blog-motto">Coding Life</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/28/baiduinterview/" title="百度历年笔试面试题(29)" itemprop="url">百度历年笔试面试题(29)</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="peng yang">peng yang</a>
    </p>
  <p class="article-time">
    <time datetime="2015-05-28T14:03:45.000Z" itemprop="datePublished">5月 28 2015</time>
    更新日期:<time datetime="2015-05-28T14:15:27.000Z" itemprop="dateModified">5月 28 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。"><span class="toc-number">1.</span> <span class="toc-text">1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2,用C语言实现函数void_memmove(void_dest,_const_void_*src,_size_t_n)。"><span class="toc-number">2.</span> <span class="toc-text">dest, const void *src, size_t n)。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间-"><span class="toc-number">3.</span> <span class="toc-text">3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。"><span class="toc-number">4.</span> <span class="toc-text">4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。"><span class="toc-number">5.</span> <span class="toc-text">5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行"><span class="toc-number">6.</span> <span class="toc-text">6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7,解释下面ptr含义和不同"><span class="toc-number">7.</span> <span class="toc-text">7,解释下面ptr含义和不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8,去掉const属性。"><span class="toc-number">8.</span> <span class="toc-text">8,去掉const属性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。"><span class="toc-number">9.</span> <span class="toc-text">10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11,SSH的原理"><span class="toc-number">10.</span> <span class="toc-text">11,SSH的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12,利用互斥量和条件变量设计一个消息队列，具有以下功能："><span class="toc-number">11.</span> <span class="toc-text">12,利用互斥量和条件变量设计一个消息队列，具有以下功能：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={_17_19_20_25_1_4_7_9}，试在这样的数组中找一元素x，看看是否存在。"><span class="toc-number">12.</span> <span class="toc-text">13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={ 17 19 20 25 1 4 7 9}，试在这样的数组中找一元素x，看看是否存在。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14,动态链接库与静态链接库的区别"><span class="toc-number">13.</span> <span class="toc-text">14,动态链接库与静态链接库的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15,指针与引用的区别"><span class="toc-number">14.</span> <span class="toc-text">15,指针与引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16,进程与线程的区别"><span class="toc-number">15.</span> <span class="toc-text">16,进程与线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17,函数调用入栈出栈的过程。"><span class="toc-number">16.</span> <span class="toc-text">17,函数调用入栈出栈的过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18,c++对象模型与虚表。"><span class="toc-number">17.</span> <span class="toc-text">18,c++对象模型与虚表。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19,海量数据处理，以及如何解决Hash冲突等问题。"><span class="toc-number">18.</span> <span class="toc-text">19,海量数据处理，以及如何解决Hash冲突等问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20,判断一个数的所有因数的个数是偶数还是奇数-"><span class="toc-number">19.</span> <span class="toc-text">20,判断一个数的所有因数的个数是偶数还是奇数.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21,指针数组和数组指针的区别。"><span class="toc-number">20.</span> <span class="toc-text">21,指针数组和数组指针的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22,查找单链表的中间结点。"><span class="toc-number">21.</span> <span class="toc-text">22,查找单链表的中间结点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23,sizeof和strlen的区别。"><span class="toc-number">22.</span> <span class="toc-text">23,sizeof和strlen的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24,malloc-free和new-delete的区别"><span class="toc-number">23.</span> <span class="toc-text">24,malloc-free和new-delete的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25,vector的实现机制-"><span class="toc-number">24.</span> <span class="toc-text">25,vector的实现机制.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26,设子数组A[0:k]和A[k+1:N-1]已排好序(0≤K≤N-1)。试设计一个合并这2个子数组为排好序的数组A[0:N-1]的算法。要求算法在最坏情况下所用的计算时间为O(N)，只用到O(1)的辅助空间。"><span class="toc-number">25.</span> <span class="toc-text"></strong></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。"><span class="toc-number">26.</span> <span class="toc-text">27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28,求全排列"><span class="toc-number">27.</span> <span class="toc-text">28,求全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29,求一个组合函数：_如p([1,2,3])_，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]"><span class="toc-number">28.</span> <span class="toc-text">29,求一个组合函数：    如p([1,2,3]) ，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]</span></a></li></ol>
		</div>
		
		<h4 id="1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。">1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">char</span> *revert(<span class="keyword">char</span> *str){
    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n /<span class="number">2</span>; i++){
        <span class="keyword">char</span> ch = str[i];
        str[i] = str[n - i - <span class="number">1</span>];
        str[n - i - <span class="number">1</span>] = ch;
    }
    <span class="keyword">return</span> str;
}
</pre></td></tr></table></figure>

<h4 id="2,用C语言实现函数void_memmove(void_dest,_const_void_*src,_size_t_n)。">2,用C语言实现函数void <em> memmove(void </em>dest, const void *src, size_t n)。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">void</span> * memmove(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t n){
    <span class="keyword">char</span> *pbTo = (<span class="keyword">char</span> *)dest;
    <span class="keyword">char</span> *pbFrom = (<span class="keyword">char</span> *)src;
    assert(dest != NULL && src != NULL);
    <span class="keyword">if</span>(dest &lt;= src || pbTo &gt;= pbFrom + n){
        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>){
            *pbTo++ = *pbFrom++;
        }
    }
    <span class="keyword">else</span>{
        pbTo = pbTo + n - <span class="number">1</span>;
        pbFrom = pbFrom +n - <span class="number">1</span>;
        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>){
            *pbTo-- = *pbFrom--;
        }
    }
    <span class="keyword">return</span> dest;
}
</pre></td></tr></table></figure>

<h4 id="3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间-">3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间.</h4>
<h4 id="4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。">4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。</h4>
<blockquote>
<p>要求：空间复杂度O(1)，时间复杂度为O（n）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">void</span> func(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len){
    <span class="keyword">int</span> begin = <span class="number">0</span>;
    <span class="keyword">int</span> end = len - <span class="number">1</span>;
    <span class="keyword">while</span>(begin &lt; end){
        <span class="keyword">while</span>((arr[begin] % <span class="number">2</span> == <span class="number">1</span>) && end &gt; begin) ++begin;
        <span class="keyword">while</span>((arr[end] % <span class="number">2</span> == <span class="number">1</span>) && end &gt; begin) --end;
        swap(arr[begin], arr[end]);
    }
}
</pre></td></tr></table></figure>

</blockquote>
<h4 id="5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。">5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。</h4>
<blockquote>
<p><a href="http://blog.csdn.net/lxmky/article/details/7985207" target="_blank" rel="external">算法</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="comment">// 算法实现</span>
<span class="keyword">struct</span> postion{
    <span class="keyword">int</span> x;
    <span class="keyword">int</span> y;
}a[<span class="number">5</span>];

<span class="keyword">int</span> cmp(position a, position b){
    <span class="keyword">if</span>(a.x == b.x){
        <span class="keyword">return</span> a.y &lt; b.y;
    }
    <span class="keyword">else</span>{
        <span class="keyword">return</span> a.x &lt; b.x;
    }
}

<span class="keyword">int</span> maxShareLen(position *a, <span class="keyword">int</span> n){
    assert(a != NULL && n &gt; <span class="number">0</span>);
    position pivot = a[<span class="number">0</span>];
    <span class="keyword">int</span> maxLen = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++){
        <span class="keyword">if</span>(a[i].x &gt;= pivot.y){
            pivot = a[i];
        }
        <span class="keyword">else</span>{
            <span class="keyword">if</span>(a[i].y &gt; pivot.y){
                maxLen = max(maxLen, (pivot.y - a[i].x));
                pivot = a[i];
            }
            <span class="keyword">else</span>{
                maxLen = max(maxLen, (a[i].y - a[i].x));
            }
        }
    }
    <span class="keyword">return</span> maxLen;
}

<span class="keyword">int</span> main(){
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++){
        <span class="built_in">cin</span>&gt;&gt;a[i].x&gt;&gt;a[i].y;
        sort(a, a + <span class="number">5</span>, cmp);
        <span class="keyword">int</span> max = maxShareLen(a, <span class="number">5</span>);
    }
}
</pre></td></tr></table></figure>

</blockquote>
<h4 id="6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行">6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行</h4>
<pre><code>   <span class="number">1.</span>不考虑系统并行性，设计一个函数（Task *Ptask,<span class="keyword">int</span> Task_num），用最快的方法完成任务。
   <span class="number">2.</span>考虑并行度，怎么设计。
   <span class="keyword">typedef</span> <span class="keyword">struct</span>{
        <span class="keyword">int</span> ID;
        <span class="keyword">int</span> * child;
        <span class="keyword">int</span> child_num;
   }Task;
   提供的函数：
   <span class="keyword">bool</span> doTask(<span class="keyword">int</span> taskID);无阻塞的运行一个任务；
   <span class="keyword">int</span> waitTask(inttimeout);返回运行完成的任务<span class="keyword">id</span>，如果没有则返回-<span class="number">1</span>；
   <span class="keyword">bool</span> killTask(<span class="keyword">int</span> taskID);杀死进程
</code></pre><h4 id="7,解释下面ptr含义和不同">7,解释下面ptr含义和不同</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">double</span>* ptr = &value;
<span class="comment">//ptr是一个指向double类型的指针，ptr的值可以改变，ptr所指向的value的值也可以改变 </span>
<span class="keyword">const</span> <span class="keyword">double</span> *ptr = &value; <span class="keyword">double</span> <span class="keyword">const</span> *ptr = &value;
<span class="comment">//ptr是一个指向constd ouble类型的指针，ptr的值可以改变，ptr所指向的value的值不可以改变</span>
<span class="keyword">double</span> * <span class="keyword">const</span> ptr = &value;
<span class="comment">//ptr是一个指向double类型的指针，ptr的值不可以改变，ptr所指向的value的值可以改变</span>
<span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> ptr = &value;
<span class="comment">//ptr是一个指向const double类型的指针，ptr的值不可以改变，ptr所指向的value的值也不可以</span>
</pre></td></tr></table></figure>

<h4 id="8,去掉const属性。">8,去掉const属性。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">0.0f</span>;
<span class="keyword">double</span> *ptr = NULL;
<span class="comment">//强制类型转换</span>
ptr = &lt;<span class="keyword">const_cast</span> <span class="keyword">double</span> *&gt;(&value);
</pre></td></tr></table></figure>

<h4 id="10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。">10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">//bitmap</span>
<span class="keyword">void</span> bitmap(){
    <span class="keyword">int</span> int_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;
    <span class="keyword">int</span> bit_len = <span class="number">0xffffffff</span> / int_len;
    <span class="keyword">int</span> *bit = <span class="keyword">new</span> <span class="keyword">int</span>[bit_len];
    <span class="keyword">int</span> v;
    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &v) != EOF){
        bit[v/int_len] |= (<span class="number">1</span> &lt;&lt; v % int_len);
    }
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bit_len; i++){
        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; int_len; j++){
            <span class="keyword">if</span>(bit[j] && (<span class="number">1</span> &lt;&lt; j) == <span class="number">0</span>){
                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i * int_len + j);
            }
        }
    }
}
</pre></td></tr></table></figure>

<h4 id="11,SSH的原理">11,SSH的原理</h4>
<h4 id="12,利用互斥量和条件变量设计一个消息队列，具有以下功能：">12,利用互斥量和条件变量设计一个消息队列，具有以下功能：</h4>
<pre><code><span class="bullet">1. </span>创建消息队列（消息中所含的元素）
<span class="bullet">2. </span>消息队列中插入消息
<span class="bullet">3. </span>取出一个消息（阻塞方式）
<span class="bullet">4. </span>取出第一消息（非阻塞方式）
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="stl_container"><span class="built_in">queue</span>&lt;msg&gt;</span> msgs;
pthread_mutex_t qready = PTHREAD_MUTEX_INITIALIZER;
ptrhead_cond_t qlock = PTHREAD_COND_INITIALIZER;

<span class="keyword">void</span> process_msg(<span class="keyword">void</span>){<span class="comment">//4</span>
    pthread_mutex_lock(&qlock);
    <span class="keyword">while</span>(msgs.size() == <span class="number">0</span>){
        pthread_cond_wait(&qready, &lock);
    }
    msg = msgs.top();
    msg.pop();
    pthread_mutex_unlock(&qlock);
}

<span class="keyword">void</span> enqueue_msg(msg m){<span class="comment">//2</span>
    pthread_mutex_lock(&qlock);
    msgs.push(m);
    pthread_mutex_unlock(&qlock);
    pthread_cond_signal(&qready);
}
</pre></td></tr></table></figure>

<h4 id="13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={_17_19_20_25_1_4_7_9}，试在这样的数组中找一元素x，看看是否存在。">13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={ 17 19 20 25 1 4 7 9}，试在这样的数组中找一元素x，看看是否存在。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">//leetcode Search in Rotated Sorted Array </span>
<span class="comment">//https://leetcode.com/problems/search-in-rotated-sorted-array/</span>
<span class="comment">//space O(1), time O(lgn)</span>
<span class="keyword">int</span> search(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target){
    <span class="keyword">int</span> l = <span class="number">0</span>;
    <span class="keyword">int</span> r = n - <span class="number">1</span>;
    <span class="keyword">if</span>(n == <span class="number">1</span>){
        <span class="keyword">return</span> (A[<span class="number">0</span>] == target) ? <span class="number">0</span> : -<span class="number">1</span>;
    }
    
    <span class="keyword">while</span>(l &lt;= r){
        <span class="keyword">if</span>(A[l] &lt;= A[r] && (target &gt; A[r] || A[l] &gt; target)){
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
        
        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;
        <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;
        
        <span class="keyword">if</span>(A[l] &lt; A[mid] && target &gt;= A[l] && target &lt; A[mid])
            r = mid - <span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(A[r] &gt; A[mid] && target &gt;= A[mid] && target &lt;= A[r])
            l = mid + <span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(A[l] &gt; A[mid])
            r = mid - <span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span>(A[r] &lt; A[mid])
            l = mid + <span class="number">1</span>;
    }
    
    <span class="keyword">return</span> -<span class="number">1</span>;
}
</pre></td></tr></table></figure>

<h4 id="14,动态链接库与静态链接库的区别">14,动态链接库与静态链接库的区别</h4>
<figure class="highlight text"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>静态链接库是.<span class="keyword">lib</span>格式的文件，一般在工程的设置界面加入工程中，程序编译时会把
<span class="keyword">lib</span>文件的代码加入你的程序中因此会增加代码大小，你的程序一运行<span class="keyword">lib</span>代码强制被
装入你程序的运行空间，不能手动移除<span class="keyword">lib</span>代码.动态链接库是程序运行时动态装入内存
的模块，格式*.dll，在程序运行时可以随意加载和移除，节省内存空间。在大型的软
件项目中一般要实现很多功能，如果把所有单独的功能写成一个个<span class="keyword">lib</span>文件的话，程序
运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就
可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内
存，这样可以节省内存空间。）
</pre></td></tr></table></figure>

<h4 id="15,指针与引用的区别">15,指针与引用的区别</h4>
<figure class="highlight text"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>相同点：<span class="number">1.</span> 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。
区别：
<span class="number">1</span>). 指针是一个实体，而引用仅是个别名；
<span class="number">2</span>). 引用使用时无需解引用(*)，指针需要解引用；
<span class="number">3</span>). 引用只能在定义时被初始化一次，之后不可变；指针可变；
<span class="number">4</span>). 引用没有 <span class="keyword">const</span>，指针有 <span class="keyword">const</span>；
<span class="number">5</span>). 引用不能为空，指针可以为空；
<span class="number">6</span>). “<span class="keyword">sizeof</span> 引用”得到的是所指向的变量(对象)的大小，而“<span class="keyword">sizeof</span> 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；
<span class="number">7</span>). 指针和引用的自增(++)运算意义不一样；
<span class="number">8</span>).从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。）
</pre></td></tr></table></figure>

<h4 id="16,进程与线程的区别">16,进程与线程的区别</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>①从概念上：
进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。
线程：一个进程内的基本调度单位。
线程的划分尺度小于进程，一个进程包含一个或者更多的线程。
②从执行过程中来看：
进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。
线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
③从逻辑角度来看：（重要区别）
多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。）
</pre></td></tr></table></figure>

<h4 id="17,函数调用入栈出栈的过程。">17,函数调用入栈出栈的过程。</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>/<span class="regexp">/http:/</span><span class="regexp">/www.cnblogs.com/biyeymyhjob</span><span class="regexp">/archive/</span><span class="number">2012</span>/<span class="number">07</span>/<span class="number">20</span>/<span class="number">2601204</span>.html
<span class="number">1</span>,堆栈中变量的分布是从高地址到低地址的分布。
<span class="number">2</span>,指向栈底，<span class="constant">ESP</span>指向栈顶
具体的过程：
<span class="number">1</span>,函数参数从右向左压入栈中。
<span class="number">2</span>,返回地址入栈。
<span class="number">3</span>,函数地址入栈后，<span class="constant">EBP</span>入栈，然后把当前的<span class="constant">ESP</span>值给<span class="constant">EBP</span>。
<span class="number">4</span>,执行函数，局部变量入栈，完毕后，局部变量出栈。
<span class="number">5</span>,<span class="constant">EBP</span>回复原值，返回地址出栈，执行原执行地址，参数出栈，调用完毕。
</pre></td></tr></table></figure>

<h4 id="18,c++对象模型与虚表。">18,c++对象模型与虚表。</h4>
<h4 id="19,海量数据处理，以及如何解决Hash冲突等问题。">19,海量数据处理，以及如何解决Hash冲突等问题。</h4>
<h4 id="20,判断一个数的所有因数的个数是偶数还是奇数-">20,判断一个数的所有因数的个数是偶数还是奇数.</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>如果一个数是平方数，因数是奇数个；
如果不是平方数，因数是偶数个 
比如<span class="number">24</span>这个数，可以把因子配对(<span class="number">1</span>,<span class="number">24</span>),(<span class="number">2</span>,<span class="number">12</span>),(<span class="number">3</span>,<span class="number">8</span>),(<span class="number">4</span>,<span class="number">6</span>)
而对于<span class="number">36</span>，因子配对(<span class="number">1</span>,<span class="number">36</span>),(<span class="number">2</span>,<span class="number">18</span>),(<span class="number">3</span>,<span class="number">12</span>),(<span class="number">4</span>,<span class="number">9</span>),(<span class="number">6</span>,<span class="number">6</span>),因为是平方数，有一组中的数重复了，所以因子数为奇数。
</pre></td></tr></table></figure>

<h4 id="21,指针数组和数组指针的区别。">21,指针数组和数组指针的区别。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">int</span> *ptr[<span class="number">10</span>];<span class="comment">//指针数组</span>
<span class="keyword">int</span> (*ptr)[<span class="number">10</span>];<span class="comment">//数组指针</span>
</pre></td></tr></table></figure>

<h4 id="22,查找单链表的中间结点。">22,查找单链表的中间结点。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>node * midlist(node *head){
    <span class="keyword">if</span>(head == NULL || head-&gt;next == NULL) <span class="keyword">return</span> head;
    
    node *p = head;
    node *q = head-&gt;next;
    <span class="keyword">while</span>(q != NULL && q-&gt;next != NULL){
        p = p-&gt;next;
        q = q-&gt;next-&gt;next;
    }
    
    <span class="keyword">return</span> p;
}
</pre></td></tr></table></figure>

<h4 id="23,sizeof和strlen的区别。">23,sizeof和strlen的区别。</h4>
<h4 id="24,malloc-free和new-delete的区别">24,malloc-free和new-delete的区别</h4>
<h4 id="25,vector的实现机制-">25,vector的实现机制.</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="number">1</span>,当调用push_back成员函数时，怎么实现？
   内存足则直接 placement <span class="keyword">new</span> 构造对象，否则扩充内存,
   转移对象，新对象placement <span class="keyword">new</span>上去
<span class="number">2</span>,当调用clear成员函数时，做什么操作，如果要释放内存该怎么做.
   调用析构函数，内存不释放。clear没有释放内存，只是将数  
   组中的元素置为空了，此时size=<span class="number">0</span>，释放内存需要<span class="keyword">delete</span>。
   v.swap(<span class="stl_container"><span class="built_in">vector</span>&lt;T&gt;</span>());<span class="comment">//清空数据</span>
</pre></td></tr></table></figure>

<h4 id="26,设子数组A[0:k]和A[k+1:N-1]已排好序(0≤K≤N-1)。试设计一个合并这2个子数组为排好序的数组A[0:N-1]的算法。要求算法在最坏情况下所用的计算时间为O(N)，只用到O(1)的辅助空间。"><strong><em>26,设子数组A[0:k]和A[k+1:N-1]已排好序(0≤K≤N-1)。试设计一个合并这2个子数组为排好序的数组A[0:N-1]的算法。要求算法在最坏情况下所用的计算时间为O(N)，只用到O(1)的辅助空间。</em></strong></h4>
<h4 id="27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。">27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">int</span> count = <span class="number">0</span>;
<span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;
<span class="keyword">while</span>(count &lt; n){
    x = rand(-r, r);
    y = rand(-<span class="built_in">sqrt</span>(r * r - x * x), <span class="built_in">sqrt</span>(r * r - x * x));
    
    <span class="keyword">if</span>(x * x + y * y != r * r){
        ++count;
    }
}
</pre></td></tr></table></figure>

<h4 id="28,求全排列">28,求全排列</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">bool</span> isSwap(<span class="built_in">string</span> str, <span class="keyword">int</span> l, <span class="keyword">int</span> r){
    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; l &lt; r; l++){
        <span class="keyword">if</span>(str[i] == str[r])
            <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">return</span> ture;
}

<span class="keyword">void</span> cur(<span class="built_in">string</span> &str, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;</span> &svec){
    <span class="keyword">if</span>(l == r){
        <span class="built_in">string</span> s(str);
        svec.push_back(s);
    }
    <span class="keyword">else</span>{
        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++){
            <span class="keyword">if</span>(isSwap(str, l, i)){
                swap(str[l], str[i]);
                cur(str, l + <span class="number">1</span>, r, svec);
                swap(str[l], str[i]);
            }
        }
    }
}
</pre></td></tr></table></figure>

<h4 id="29,求一个组合函数：_如p([1,2,3])_，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]">29,求一个组合函数：    如p([1,2,3]) ，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="stl_container"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;</span> istack;
<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;</span> istr;
<span class="keyword">void</span> print_stack(){
	<span class="keyword">if</span>(istack.empty()) <span class="keyword">return</span>;
	<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> ivec;
	<span class="built_in">string</span> s = <span class="string">""</span>;
	<span class="keyword">while</span> (!istack.empty()){
		<span class="keyword">int</span> c = istack.top();
		s += c;
		ivec.push_back(c);
		istack.pop();
	}
	<span class="comment">//cout&lt;&lt;s&lt;&lt;endl;</span>
	<span class="keyword">if</span>(find(istr.begin(), istr.end(), s) == istr.end()){
		<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;endl;
		istr.push_back(s);
	}
	<span class="keyword">for</span>(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>::reverse_iterator iter = ivec.rbegin(); 
	                iter != ivec.rend(); iter++){
		istack.push(*iter);
	}
	ivec.clear();
}
<span class="keyword">void</span> enum_array(<span class="keyword">char</span> *p, <span class="keyword">int</span> n){
	<span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span>;
	print_stack();
	istack.push(p[n - <span class="number">1</span>]);
	enum_array(p, n - <span class="number">1</span>);
	istack.pop();
	enum_array(p, n - <span class="number">1</span>);
}
</pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/算法-面试/">算法 面试</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/05/28/baiduinterview/" data-title="百度历年笔试面试题(29) | yangpengACE`s Blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2014/07/02/mianshi/"  title="面试遇见的问题">
 <strong>NEXT:</strong><br/> 
 <span>面试遇见的问题
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。"><span class="toc-number">1.</span> <span class="toc-text">1,用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2,用C语言实现函数void_memmove(void_dest,_const_void_*src,_size_t_n)。"><span class="toc-number">2.</span> <span class="toc-text">dest, const void *src, size_t n)。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间-"><span class="toc-number">3.</span> <span class="toc-text">3,有一根27厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，不能同时通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，求所有蚂蚁都离开木杆的最小时间和最大时间.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。"><span class="toc-number">4.</span> <span class="toc-text">4,给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。"><span class="toc-number">5.</span> <span class="toc-text">5,在一维坐标轴上有n个区间段，求重合区间最长的两个区间段。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行"><span class="toc-number">6.</span> <span class="toc-text">6,系统有很多任务，任务之间有依赖，比如B依赖于A，则A执行完后B才能执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7,解释下面ptr含义和不同"><span class="toc-number">7.</span> <span class="toc-text">7,解释下面ptr含义和不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8,去掉const属性。"><span class="toc-number">8.</span> <span class="toc-text">8,去掉const属性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。"><span class="toc-number">9.</span> <span class="toc-text">10,现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11,SSH的原理"><span class="toc-number">10.</span> <span class="toc-text">11,SSH的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12,利用互斥量和条件变量设计一个消息队列，具有以下功能："><span class="toc-number">11.</span> <span class="toc-text">12,利用互斥量和条件变量设计一个消息队列，具有以下功能：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={_17_19_20_25_1_4_7_9}，试在这样的数组中找一元素x，看看是否存在。"><span class="toc-number">12.</span> <span class="toc-text">13,对已排好序的数组A，一般来说可用二分查找可以很快找到。现有一特殊数组A[]，它是循环递增的，如A[]={ 17 19 20 25 1 4 7 9}，试在这样的数组中找一元素x，看看是否存在。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14,动态链接库与静态链接库的区别"><span class="toc-number">13.</span> <span class="toc-text">14,动态链接库与静态链接库的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15,指针与引用的区别"><span class="toc-number">14.</span> <span class="toc-text">15,指针与引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16,进程与线程的区别"><span class="toc-number">15.</span> <span class="toc-text">16,进程与线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17,函数调用入栈出栈的过程。"><span class="toc-number">16.</span> <span class="toc-text">17,函数调用入栈出栈的过程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18,c++对象模型与虚表。"><span class="toc-number">17.</span> <span class="toc-text">18,c++对象模型与虚表。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19,海量数据处理，以及如何解决Hash冲突等问题。"><span class="toc-number">18.</span> <span class="toc-text">19,海量数据处理，以及如何解决Hash冲突等问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20,判断一个数的所有因数的个数是偶数还是奇数-"><span class="toc-number">19.</span> <span class="toc-text">20,判断一个数的所有因数的个数是偶数还是奇数.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21,指针数组和数组指针的区别。"><span class="toc-number">20.</span> <span class="toc-text">21,指针数组和数组指针的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22,查找单链表的中间结点。"><span class="toc-number">21.</span> <span class="toc-text">22,查找单链表的中间结点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23,sizeof和strlen的区别。"><span class="toc-number">22.</span> <span class="toc-text">23,sizeof和strlen的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24,malloc-free和new-delete的区别"><span class="toc-number">23.</span> <span class="toc-text">24,malloc-free和new-delete的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25,vector的实现机制-"><span class="toc-number">24.</span> <span class="toc-text">25,vector的实现机制.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26,设子数组A[0:k]和A[k+1:N-1]已排好序(0≤K≤N-1)。试设计一个合并这2个子数组为排好序的数组A[0:N-1]的算法。要求算法在最坏情况下所用的计算时间为O(N)，只用到O(1)的辅助空间。"><span class="toc-number">25.</span> <span class="toc-text"></strong></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。"><span class="toc-number">26.</span> <span class="toc-text">27,设rand（s，t）返回[s,t]之间的随机小数，利用该函数在一个半径为R的圆内找随机n个点，并给出时间复杂度分析。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28,求全排列"><span class="toc-number">27.</span> <span class="toc-text">28,求全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29,求一个组合函数：_如p([1,2,3])_，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]"><span class="toc-number">28.</span> <span class="toc-text">29,求一个组合函数：    如p([1,2,3]) ，输出：[1],[2],[3],[1,2],[2,3],[1,3],[1,2,3]</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Books/" title="Books">Books<sup>1</sup></a></li>
		
			<li><a href="/tags/C++/" title="C++">C++<sup>2</sup></a></li>
		
			<li><a href="/tags/GOT/" title="GOT">GOT<sup>1</sup></a></li>
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/算法/" title="算法">算法<sup>1</sup></a></li>
		
			<li><a href="/tags/算法-面试/" title="算法 面试">算法 面试<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://lovezhq.500yun.pw/" target="_blank" title="LoveZHQ">Love依米</a></li>
	  <li><a href="http://lovezhq.500yun.pw/2048/index.html" target="_blank" title="2048">2048`s GAME</a></li>
      <li><a href="http://zespia.tw/hexo" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Yang peng in BJUT <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2422515872" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/yangwii" target="_blank" title="github"></a>
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="peng yang">peng yang</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



  </body>
</html>
